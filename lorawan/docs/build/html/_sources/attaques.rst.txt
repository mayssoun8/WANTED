Attaques
========

Attaque sur clés basiques
*************************

Contexte
---------

Dans un réseau LoRaWAN agricole utilisant une version obsolète de LoRaMAC (comme la 1.0.x), plusieurs failles de sécurité sont présentes :

- **Ancienne version du protocole** : LoRaMAC 1.0.x utilise moins de clés de sécurité, ce qui le rend vulnérable par rapport à la version 1.1.x.
- **Identifiants faibles et prévisibles** : Certains DevEUI et AppKey comme `000...`, `111...`, ou `123...` sont faciles à deviner, facilitant les attaques par force brute.

Ces vulnérabilités rendent le réseau facile à attaquer. L'objectif est d'exploiter cette faiblesse liée au choix des identifiants.

Méthodologie de l'attaque
-------------------------

L'attaque repose sur la force brute du **DevEUI** et de l'**AppKey**, ce qui permet d'établir une connexion avec la passerelle et d'envoyer ensuite des données falsifiées.

Rappel des clés de sécurité dans LoRaMAC 1.0.x en utilisant OTAA
----------------------------------------------------------------

- **AppKey** : Sécurise l'activation OTAA et génère les clés de session.
- **AppSKey** : Chiffre/déchiffre les données utilisateur.
- **NwkSKey** : Assure l'intégrité des messages MAC.

Contre-mesures et recommandations
---------------------------------

- Mettre à jour vers **LoRaMAC 1.1.x** pour bénéficier des améliorations de sécurité.
- Utiliser des clés cryptographiques **complexes et aléatoires**, difficiles à deviner.
- **Renouveler régulièrement** les clés du réseau pour limiter l'exposition en cas de fuite.

Améliorations possibles
------------------------

- **Étendre la bibliothèque de clés** pour tester un plus grand nombre de combinaisons courantes dans les déploiements vulnérables.
- **Optimiser les délais d'attente** pour réduire le temps total d'exécution sans compromettre la fiabilité des tests.

Limites de l'attaque
--------------------

- **Temps d'exécution croissant** : Plus le nombre de clés testées est élevé, plus le temps de brute-force augmente de manière exponentielle.
- **Délais à respecter** : Chaque test doit respecter un délai (~10-15s) pour laisser la connexion s'établir.
- **Absence de ciblage précis** : L'attaque ne permet pas de choisir un réseau spécifique.

Lors des tests, nous avons pu rejoindre un réseau en utilisant des identifiants faibles comme :

- **DevEUI** : `1111111111111111`
- **AppKey** : `11111111111111111111111111111111`

Ou encore :

- **DevEUI** : `AAAAAAAAAAAAAAAA`
- **AppKey** : `AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA`

Ces valeurs n'étaient pas incluses dans notre banc de test initial, ce qui montre qu'un réseau avec de telles configurations était accessible.

**Conclusion** : Bien que l'attaque soit efficace contre des identifiants faibles, son efficacité dépend fortement du contexte et du nombre de clés testées.

Déploiement
-----------

Le code source de cette attaque est disponible dans le répertoire :  
``attaques/attaque_cles_basiques``

Deux plateformes matérielles peuvent être utilisées :

1. **Arduino Dragino**  
2. **LoPy4** (déjà utilisé comme nœud légitime, donc moins privilégié ici)

Utilisation avec LoPy4
~~~~~~~~~~~~~~~~~~~~~~
Si on veut quand même utiliser un **LoPy4** pour cette attaque, il suffit de flasher le code contenu dans :

``attaques/attaque_cles_basiques/pycom``  

via **Pymakr** sur un autre LoPy4, comme nous l'avons fait pour le nœud légitime.

Utilisation avec Arduino Dragino
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Avant de commencer, il faut installer la bibliothèque **MCCI LoRaWAN LMIC** disponible ici :  
`https://github.com/mcci-catena/arduino-lorawan.git`

Cette bibliothèque est disponible directement dans **Arduino IDE** et permet de créer un nœud LoRaWAN avec du matériel Arduino Dragino, ce qui est indispensable pour réaliser cette attaque.

Une fois la bibliothèque installée, il suffit de :

1. Ouvrir le fichier :  
   ``attaques/attaque_cles_basiques/arduino/attaquesArduino.ino``
2. Téléverser le code sur la carte :

   - Via **Arduino IDE**, puis observer le moniteur série.
   - Ou en ligne de commande :  
     ```
     arduino --upload attaqueArduino.ino --port /dev/ttyACM1
     ```
   - Pour voir la sortie, utiliser **minicom** :  
     ```
     minicom -D /dev/ttyACM1 -b 9600
     ```

---

Sniffing
********

Contexte
--------

Le sniffing LoRaWAN consiste à intercepter passivement les communications radio entre les dispositifs et la passerelle. Cette technique permet :

- D'analyser le trafic réseau pour identifier des vulnérabilités
- De capturer des paquets pour des attaques ultérieures (comme le rejeu)
- De diagnostiquer des problèmes de configuration

Méthodologie
------------

1. **Configuration matérielle** :
   - Utilisation d'un Arduino Dragino
   - Réglage de la fréquence LoRa (868 MHz en Europe)

2. **Capture des paquets** :
   - Interception des messages Join-Request et Data Up
   - Décodage des en-têtes LoRaWAN (MHDR, DevEUI, etc.)

3. **Analyse des trames** :
   - Conversion little-endian/big-endian
   - Vérification des MIC (Message Integrity Code)

Exemple de paquets capturés
----------------------------

Join-Request typique :

.. code-block:: none

   00 00 00 00 00 00 00 00 00 57 2A 71 99 49 D5 B3 70 DD 7C 93 36 E4 C9

- **MHDR (0x00)** : Join-Request
- **AppEUI** : 00 00 00 00 00 00 00 00 (valeur par défaut)
- **DevEUI** : 70 B3 D5 49 99 71 2A 57 (après conversion big-endian)
- **DevNonce** : DD 7C
- **MIC** : 93 36 E4 C9

Trames Data Up :

.. code-block:: none

   40 E2 F1 54 00 00 00 00 02 6F BD 26 07 55 5E 51 5A BA 78 C1 AE E8 76 D0 23 15 FA
   40 E2 F1 54 00 00 03 00 02 86 4F A9 79 3E C1 42 97 4E 06 F4 F4 1E E2 75 BC 79 BD 

- **MHDR (0x40)** : Unconfirmed Data Up
- **FCnt** : 00 00 puis 03 00 (incrémentation visible)

Outils nécessaires
-------------------

- **Matériel** :
  - Arduino Dragino
  - Antenne LoRa compatible 868MHz

- **Logiciels** :
  - Bibliothèque `arduino-LoRa <https://github.com/sandeepmistry/arduino-LoRa>`_
  - Minicom pour l'analyse des logs

Déploiement
-----------

Installation du sniffer
~~~~~~~~~~~~~~~~~~~~~~~
1. Flasher le code sur l'Arduino :

   .. code-block:: bash

      arduino --upload attaques/attaque_rejeu/replay_arduino/arduino_sniffer/arduino_sniffer.ino --port /dev/ttyACM1

2. Visualisation des paquets avec Minicom :

   .. code-block:: bash

      minicom -D /dev/ttyACM1 -b 9600

Automatisation avec le script sniffer
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Le script ``sniffer.sh`` permet d'automatiser la capture :

.. code-block:: bash

   ./attaques/attaque_rejeu/replay_arduino/arduino_sniffer/sniffer.sh \
     -p /dev/ttyACM1 \
     -b 9600 \
     -o captures.txt

Options disponibles :

- ``-p`` : Port série (par défaut /dev/ttyACM1)
- ``-b`` : Baud rate (par défaut 9600)
- ``-o`` : Fichier de sortie

Analyse avancée
---------------

Pour interpréter les captures :

1. **Identifier le type de message** via le MHDR :
   - ``0x00`` : Join-Request
   - ``0x40`` : Unconfirmed Data Up
   - ``0x80`` : Confirmed Data Up

2. **Extraire les identifiants** :
   - DevEUI (octets 9-16 en little-endian)
   - AppEUI (octets 1-8)

3. **Vérifier l'intégrité** :
   - Les 4 derniers octets représentent le MIC
   - Doivent correspondre au calcul AES-CMAC avec la NwkSKey

Contre-mesures
--------------

- **Activer le chiffrement** (AES-128) pour empêcher la lecture des payloads
- **Utiliser des MIC robustes** et vérifier systématiquement leur validité

Limites
-------

- **Portée limitée** : Nécessité d'être à proximité physique du réseau
- **Dépendance matérielle** : Sensibilité du récepteur
- **Interprétation partielle** : Sans accès aux clés, certains champs restent illisibles (écoute possible mais incompréhensible si réseau bien configuré)

---

Attaque par rejeu
*****************

Contexte
--------

Dans un réseau LoRaWAN vulnérable, l'attaque par rejeu (*replay attack*) exploite la retransmission de paquets légitimes capturés pour :

- Perturber le réseau en saturant la passerelle.
- Falsifier des données (exemple : fausses mesures de capteurs).
- Contourner les mécanismes d'authentification si les compteurs de trames (FCnt) ou les MIC ne sont pas vérifiés.

Cette attaque est particulièrement efficace si :

- Le réseau n'utilise pas de compteurs de trames incrémentiels.
- Les MIC ne sont pas recalculés après capture.

Méthodologie de l'attaque
-------------------------

1. **Capture de paquets** :
   - Utilisation d'un sniffer (exemple : LoRattack avec USRP) ou d'un Arduino Dragino avec l'outil de sniffing défini dans la section Sniffing de cette documentation.
   - Filtrage des paquets *Unconfirmed Data Up* (MHDR = `0x40`).

2. **Analyse des trames** :
   - Extraction du **DevEUI**, **FCnt**, et **MIC**.
   - Conversion des formats (little-endian/big-endian).

3. **Rejeu automatisé** :
   - Réinjection des paquets capturés avec modification du FCnt.
   - Optionnel : Recalcul du MIC si la NwkSKey est connue (rare en pratique).

Exemple de paquet capturé
-------------------------

.. code-block:: none

   40 E2 F1 54 00 00 05 00 02 BF AE FF F4 7D 78 9A A3 0E 61 44 A7 39 90 93 9E 25 E2

- **MHDR (0x40)** : *Unconfirmed Data Up*.
- **FCnt** : `05 00` (valeur incrémentielle).
- **MIC** : `93 9E 25 E2` (vérifié par la passerelle).

Outils nécessaires
------------------

- **Matériel** :
  - Carte Arduino Dragino de préférence ou USRP (pour LoRattack).
- **Logiciels** :
  - `LoRattack <https://github.com/konicst1/lorattack>`_ (sniffing/rejeu).
  - Bibliothèque `arduino-LoRa <https://github.com/sandeepmistry/arduino-LoRa>`_.

Déploiement
-----------

Avec LoRattack (USRP)
~~~~~~~~~~~~~~~~~~~~~
1. Installer les dépendances :

   .. code-block:: bash

      sudo apt install gnuradio bittwist uhd-host
      git clone https://github.com/konicst1/lorattack.git
      cd lorattack && ./run.sh

2. Capturer et rejouer les paquets :

   .. code-block:: bash

      # Capture
      Lancer ./run.sh et sélectionner le sniffing.
      # Rejeu
      Lancer ./run.sh et sélectionner le replay à partir d'un fichier pcap obtenu dans l'étape précédente.

Avec Arduino Dragino (de manière manuelle)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
1. Flasher le code de rejeu en veillant à modifier le paquet à rejouer dans le code source :

   .. code-block:: bash

      arduino --upload attaques/attaque_rejeu/replay_arduino/arduino_player/arduino_player.ino --port /dev/ttyACM1

2. Analyser les logs via minicom :

   .. code-block:: bash

      minicom -D /dev/ttyACM1 -b 9600

Avec Arduino Dragino (de manière automatisée)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
1. Flasher le code de rejeu automatisé :

   .. code-block:: bash

      arduino --upload attaques/attaque_rejeu/replay_arduino/arduino_total_replay/arduino_total_replay.ino --port /dev/ttyACM1

2. Analyser les logs via minicom :

   .. code-block:: bash

      minicom -D /dev/ttyACM1 -b 9600

Contre-mesures
--------------

- **Validation stricte du FCnt** : Rejeter les paquets avec un compteur inférieur ou égal à la dernière valeur enregistrée.
- **Rotation des clés de session** : Limiter la durée de vie des NwkSKey/AppSKey, en renouvelant les sessions régulièrement.
- **Chiffrement de bout en bout** : Empêcher la lecture/modification des payloads.

Limites
-------

- **Efficacité réduite** : Si le réseau vérifie les MIC et FCnt, les paquets rejoués sont ignorés.
- **Portée limitée** : Nécessite une proximité physique avec le réseau cible.
- **Complexité** : Recalculer le MIC sans connaître la NwkSKey est impossible.

Exemple pratique
----------------

Un paquet rejoué avec succès (FCnt incrémenté) :

.. code-block:: none

   [ORIGINAL]  40...05 00...93 9E 25 E2
   [REPLAYED]  40...06 00...A1 B2 C3 D4  # MIC invalide, mais FCnt mis à jour

Ce paquet sera visible dans les logs du sniffer, mais rejeté par ChirpStack sans MIC valide.

---

Attaque de brouillage
*********************